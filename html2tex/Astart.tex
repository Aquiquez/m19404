\documentclass[fontsize=12pt, % Document font size
                             paper=a4, % Document paper type
                             oneside, % Shifts odd pages to the left for easier reading when printed, can be changed to oneside
                             captions=tableheading,
                             index=totoc,
                             hyperref]{labbook}
 
\usepackage[bottom=10em]{geometry} % Reduces the whitespace at the bottom of the page so more text can fit
%\usepackage{media9}
%\usepackage[dvipdfmx]{media9} 
%\usepackage[svgnames]{xcolor}
\usepackage[english]{babel} % English language
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template


%\usepackage[utf8]{inputenc} % Uses the utf8 input encoding
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{lmodern}
%\usepackage{fontspec}
\usepackage{emerald}
%usepackage{va}
%\usepackage{frcursive}
%\usepackage{calligra}

%\setmainfont{\ECFTeenSpirit}

%\renewcommand{\fontfamily{emerald}}{\ECFTeenSpirit}

%\renewcommand{\rmdefault}{emerald}
%\renewcommand{\familydefault}{pag}

%\usepackage[osf]{mathpazo} % Palatino as the main font
%\linespread{1.05}\selectfont % Palatino needs some extra spacing, here 5% extra
%\usepackage[scaled=.88]{beramono} % Bera-Monospace
%\usepackage[scaled=.86]{berasans} % Bera Sans-Serif

\usepackage{booktabs,array} % Packages for tables

\usepackage{amsmath} % For typesetting math

\newcommand{\fullpage}[1]{
\begin{frame}
 #1
\end{frame}
}
\usepackage{movie15}  

\usepackage{etoolbox}
\usepackage[norule]{footmisc} % Removes the horizontal rule from footnotes
\usepackage{lastpage} % Counts the number of pages of the document
\usepackage{color}
\usepackage{listings}

\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.5,0.5}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0,1}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0,0.63,0}
\definecolor{Comments}{rgb}{0,0.63,1}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{0.98,0.98,0.98}



%\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

\usepackage[dvipsnames]{xcolor}  % Allows the definition of hex colors
\definecolor{titleblue}{rgb}{0.16,0.24,0.64} % Custom color for the title on the title page
\definecolor{linkcolor}{rgb}{0,0,0.42} % Custom color for links - dark blue at the moment
%\setkomafont{main}{\ECFAugie}
%\renewcommand*{\familydefault}{\normalfont}
%\setkomafont{}{\normalfont\ECFAugie}
%\renewcommand*{\seriesdefault}{\ECFAugie}
%\addtokomafont{hyperref}{\color{Sepia}}
\addtokomafont{title}{\ECFAugie\color{Mahogany}} % Titles in custom blue color
\addtokomafont{chapter}{\ECFAugie\color{LimeGreen}} % Lab dates in olive green
\addtokomafont{section}{\ECFAugie\color{Cyan}} % Sections in sepia
\addtokomafont{subsection}{\ECFAugie\color{LimeGreen}} % Sections in sepia
\addtokomafont{subsubsection}{\ECFAugie\color{Orange}} % Sections in sepia
\addtokomafont{pagehead}{\ECFAugie\color{Red}} % Header text in gray and sans serif
\addtokomafont{caption}{\ECFAugie\footnotesize\itshape} % Small italic font size for captions
\addtokomafont{captionlabel}{\ECFAugie\upshape\bfseries} % Bold for caption labels
\addtokomafont{descriptionlabel}{\ECFAugie}
\setcapwidth[r]{10cm} % Right align caption text
\setkomafont{footnote}{\sffamily} % Footnotes in sans serif

\deffootnote[4cm]{4cm}{1em}{\textsuperscript{\thefootnotemark}} % Indent footnotes to line up with text

\DeclareFixedFont{\textcap}{T1}{fjd}{bx}{n}{1.5cm} % Font for main title: Helvetica 1.5 cm
\DeclareFixedFont{\textaut}{T1}{fjd}{bx}{n}{0.8cm} % Font for author name: Helvetica 0.8 cm

\usepackage[nouppercase,headsepline]{scrpage2} % Provides headers and footers configuration
\pagestyle{scrheadings} % Print the headers and footers on all pages
\clearscrheadfoot % Clean old definitions if they exist

\automark[chapter]{chapter}
\ohead{\headmark} % Prints outer header

\setlength{\headheight}{25pt} % Makes the header take up a bit of extra space for aesthetics
\setheadsepline{.4pt} % Creates a thin rule under the header
\addtokomafont{headsepline}{\ECFAugie\color{lightgray}} % Colors the rule under the header light gray

\ofoot[\normalfont\normalcolor{\thepage\ |\  \pageref{LastPage}}]{\normalfont\normalcolor{\thepage\ |\  \pageref{LastPage}}} % Creates an outer footer of: "current page | total pages"

% These lines make it so each new lab day directly follows the previous one i.e. does not start on a new page - comment them out to separate lab days on new pages
\makeatletter
\patchcmd{\addchap}{\if@openright\cleardoublepage\else\clearpage\fi}{\par}{}{}
\makeatother
\renewcommand*{\chapterpagestyle}{scrheadings}

% These lines make it so every figure and equation in the document is numbered consecutively rather than restarting at 1 for each lab day - comment them out to remove this behavior
\usepackage{chngcntr}
\counterwithout{figure}{labday}
\counterwithout{equation}{labday}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
 
\lstset{ %
  language=C++,                % the language of the code
  basicstyle=\footnotesize\ttfamily,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{black},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{dkgreen},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={Rect,...},              % if you want to add more keywords to the set
  deletekeywords={...}              % if you want to delete keywords from the given language
}

%Hyperlink configuration
\usepackage[
    pdfauthor={pi19404}, % Your name for the author field in the PDF
   % pdftitle={Article}, % PDF title
   % pdfsubject={}, % PDF subject
    %bookmarksopen=true,
    %linktocpage=true,
    urlcolor=Goldenrod, % Color of URLs
    citecolor=Goldenrod, % Color of citations
    linkcolor=Goldenrod, % Color of links to other pages/figures
    %backref=page,
    pdfpagelabels=true,
    plainpages=false,
    colorlinks=true, % Turn off all coloring by changing this to false
    bookmarks=true,
    pdfview=FitB]{hyperref}

%\usepackage[stretch=10]{microtype} % Slightly tweak font spacing for aesthetics

%\usepackage{pdfpages}                    % prikaz \includepdf
%\usepackage{attachfile}
%\usepackage{embedfile}
%\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{movie15}
%\usepackage{media9}
%\usepackage[sort,sectionbib,square,round,authoryear]{natbib}
%\usepackage[sort]{cite}

%\usepackage{natbib}
\usepackage{filecontents}
\usepackage[natbib=true,citestyle=authoryear,bibstyle=numeric]{biblatex} 
%pdflatex dtw.tex;bibtex dtw.aux;pdflatex dtw.tex
\usepackage{graphicx}
% declare known graphics extensions
\DeclareGraphicsExtensions{.jpg,.jpeg,.pdf,.png,.mps,.gif}
\newcommand{\vurl}[1]{\url{#1}}
\usepackage{animate}
\usepackage{eso-pic}
\newcommand\BackgroundPic{
\put(0,0){
\parbox[b][\paperheight]{\paperwidth}{%
\vfill
\centering
\includegraphics[width=\paperwidth,height=\paperheight]{../back.jpg}%
\vfill
}}}
\renewcommand*{\compcitedelim}{\addsemicolon\space}
%\setlength\parindent{0pt} % Uncomment to remove all indentation from paragraphs
\usepackage{minted}
\ECFAugie\color{lightgray}
\bibliography{test} 
\begin{document}
\AddToShipoutPicture{\BackgroundPic}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
\ECFAugie\color{lightgray}
\title{\textcap{Robotic Path Planning and navigation :A* Algorithm \\[2cm]  
%\textaut{Beginning 30-05-2012}
}}
\author{
    \textaut{Pi19404}\\ \\ % Your name
    %Master of Science % Your degree
}
%\ECFJD{\today} % No date by default, add \today if you wish to include the publication date

\maketitle % Title page
\printindex
\tableofcontents % Table of contents
\newpage % Start lab look on a new page
%
%\begin{addmargin}[0cm]{0cm} % Makes the text width much shorter for a compact look
%
\pagestyle{scrheadings} % Begin using headers
%
\ECFAugie\color{White}
\labday{Robotic Path Planning and navigation :A* Algorithm }

%\ECFTeenSpirit
%\section{Augie} {\ECFJD\lipsum[4]}
%\section{Auriocus Kalligraphicus} {\Fontauri\lipsum[4]}
%\section{BrushScriptX-Italic} {\bsifamily\lipsum[4]}

\section{Introduction}
In the article we will look at implementation of A* graph search algorithm for robotic
path planning and navigation.

\section{A* Path Planning}
The aim of path planning algorithms is to find a path from the source to goal position.
\\\\
We work under the following assumptions :
\begin{itemize}
 \item Point Robot with Ideal Localization
 \item Workspace is bounded and known
 \item Static source,goal and obstacle locations
 \item Number of obstacles are finite 
 \item Obstacles have finite thickness
\end{itemize}
The discrete path planning task which is posed as posed as graph search problem.
\\\\
A* is a widely used graph traversal algorithm that uses Best First Search approach to 
find least cost path from the source to destination node.
\\\\
\begin{itemize}
 \item Workspace divided into discrete grids
 \item Each grid represents vertex of graph
 \item Edges defined by connected components of grids
 \item If adjacent grid points inside obstacles it is not connected
 \item If adjacent grid points in free space it is connected
\end{itemize}
Adjacent grids of the workspace are considered
to be connected by a edge.Each edge is associated with a cost defined using a cost function $f(n)$.
\\\\
The cost can be defined using various criteria based on information about source,goal,obstacles,current
node position in the graph.
\\\\
Typical graph search algorithms find a minimum cost path from source to destination node.
\\\\
For path finding application the cost is directly related to distance of grid/node from source
and destination nodes.
\\\\
The the minimum-cost path provides a path with shortest-distance from source to destination grid.
\\\\
The input to simulation environment is provided in form of a image
\begin{figure}[!htbp]
\begin{subfigure}[b]{0.5\textwidth}
                 \centering
                 \includegraphics[width=\textwidth]{obstacles1.png}
                 \caption{Workspace}
\end{subfigure}                
\begin{subfigure}[b]{0.5\textwidth}
                 \centering
                 \includegraphics[width=\textwidth]{image_036.png}
                 \caption{Workspace 2}
\end{subfigure}  
\caption{Workspace}
\label{fig:1}
\end{figure}
\subsection{Informed Search Algorithms}
Breadth first or Depth First search are un-informed search algorithms where all
the nodes along the breadth of depth of graph are explored till a goal node is found.
\\\\
A large number of nodes are explored in the process.
\\\\
We can reduce search space using additional information about the problem.
\\
Such methods are called as informed search algorithms which
Consider Cost of paths ,heuristic distance from goal state etc to decide path most likely to lead to a goal
or some information about the problem at hand to choose the most likely node that will
lead to goal position.
\\\\
A* Uses Best First search strategy to explore the graph by expanding the best node 
(shortest path) according to a predefine criteria.
\\\\
It Chooses the node that has the lowest value for the cost function which is defined as 
\\\\
$f(n) = g(n) + h(n)$,where 
\\\\
$g(n)$ is exact cost of the path - initial node to present node \\
$h(n)$ is estimated heuristic cost - current node to the goal 
\\\\
The A* algorithm can considered to operate in 2 states
\begin{itemize}
 \item {Find the node associated with minimum cost}
 \item {Expand the node }
\end{itemize}
By expanding the node we mean that all the connected components of the nodes
are considered to be potential candidates for best node in the next iteration of the algorithm
\\\\
\subsection{Implementation Details : Algorithm 1}
The simplest data structure that can be used is a $ \texttt{SET} $.
\\\\
Let call the set $\texttt{OPEN\_LIST}$.Initially a $\texttt{OPEN\_LIST}$ contains the only source node.
\\\\
The algorithm is as follows
\begin{itemize}
 \item find element from minimum cost from the set
 \item Stop if goal node is reach and trace back the path
 \item add the successors of the element(expand the node),that lie in free position in workspace to set
\item If set is empty ,no path to the goal is found.
\end{itemize}
This algorithm is not completed.It does not always find a path between source and goal
even if the path exists
\\\\
It can get stuck in loop especially at dead ends,or large obstacles are encountered
especially in situations when we encounter a node with only successor being its parent.
\\\\
Below is the simulation output in which algorithm is stuck in a loop
when using just open list.\\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s1.ogv}
\\\\
Below is the simulation in which algorithm is stuck in a loop when
we do not consider \\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s2.ogv}
\\\\
Below is simulation output with open and closed list changes\\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s3.ogv}
\\\\
Also it can happen that we visit a node already present in open list,thus algorithm
will be stuck in a loop .This can happen when large obstacles are encountered
\\\\
To solve the problem we maintain another set call $\texttt{CLOSED\_LIST}$.
\\\\
This will contain the nodes which were already expanded,ie minimum cost nodes.
If a node is already present in the closed list ,it will not be considered
again for expansion or we can visit this node only a finite number of times
\\\\
This will avoid the problem of getting stuck in loops.
\\\\
Also if a node is already present in the open list,we check the cost of the node present
in the list.The cost is higher,the node is replaced with new node else the new node
is not considered for expansion.
\\\\
Thus we will consider a new node for expansion if it lies in the open list
only if path through the node leads to lower cost than the path through the node
already present in the list
\\\\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s5.ogv}  
\subsection{Admissibility}
If the heuristic does not overestimate the true cost to the goal,then
the A* algorithm will always find the optimal solution and A* is said to
use an admissible heuristic.
\\\\
The admissible heuristic is too optimistic ,it will lead $A^*$ to
search paths that turn out to be more costly than optimal paths.
\\\\
It will not prevent A* from expanding a node that is on the optimal path ,which can happen
if heuristic value is too high
\\\\
Some heuristics are better than others,We want heuristic to be as close to the true cost as possible.
A heuristic will mislead ,if the true cost to goal is very large compared to the estimate.
\\\\
If we have two admissible heuristic functions $h_1,h_2$,then if $h_1 > h_2 \text{for all} N$ ,
then $h_1$ is said to dominate $h_2$ or $h_1$ is better than $h_2$.
\\\\
Below is the simulation with heuristic $h(n)=0$,this is worst possible heuristic
it does not help in reducing the search space at all,This is called as uniform cost search
\\\\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s6.ogv}
we can see than it is admissible and finds the optimal path.
\\\\
if we consider the euclidean distance as heuristic,the true distance will
always be greater than or equal to euclidean distance hence lead to the optimal
path
\\\\
Let us consider a heuristic function $(1+\varepsilon) h(n),\varepsilon >1$.
\\\\
Thus will lead to overestimation of true distance/cost to the goal.
The overestimation causes the cost biased towards the heuristic ,rather than
true cost to travel to the mode.
\\\
The path will tend to be skewed towards the goal position.
\\\\
Below simulation is output with $\varepsilon=5$\\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s4.ogv}
\\\\
Below simulation is output with $\varepsilon=1$\\
\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s5.ogv}
Thus we can see that overestimation of heuristic function produces a non optimal path.
\\\\
%\subsection{Optimality}

\subsection{Non Optimal Paths}
A* expands all the equally potential nodes,large number of nodes are analyzed.
\\\\
If we are able to relax the optimality condition,we can benefit from faster
execution times.
\\\\
For example we can use static weighing of the cost function
\[
 f(n) = g(n) + (1+ \varepsilon) h(n)
\]
if $h(n)$ is admissible heuristic ,the algorithm will find path with optimal cost $L$.
\[
   f(n)=g(n)+h(n) \le L
\]
\\\\
If we overestimate the cost,a point not on the optimal path would be selected,The algorithm
will overlook the optimal solution .
%\\\\
%Below is simulation of selecting heuristic as $5*h(n)$,this surely not admissible for all nodes
%especially once near the edge of large obstacle.This heuristic will tend to move towards goal,along non optimal path
%initially near the edge of the obstale
%\vurl{https://googledrive.com/host/0B-pfqaQBbAAtenZiNDItSDFTSTg/s6.avi}
%\\\\
Let $h^*(n)$ give true cost from node to goal.
\begin{eqnarray*}
 h(N) \le c(N,P) + h(P) \\
 h(N_m) \le h^*(N_m) \\
 h(N_{m+1}) \le C(N_m,N_{m+1})+h(N_m) \le C(N_m,N_{m+1}) + h^*(N_m) = h^*(N_{m+1})
\end{eqnarray*}
Thus if we estimate the cost as $h_1(n)$ which is not admissible heuristic
\\\\
\begin{eqnarray*}
(1+\varepsilon)h(N_{m+1}) > h^*(N_{m+1}) \\
h_1(N_{m+1})=(1+\varepsilon)h(N_{m+1})  < (1+\varepsilon)h^*(N_{m+1})  \\
\end{eqnarray*}
Thus the worse heuristic can do $(1+\varepsilon)$ times the best
path.
\\\\
\subsection{Implementation Details}
$\texttt{GNode}$  is class that represents the node of a graph,it
also contains information about the adjacent nodes of graph.
\\\\
$\texttt{AStar}$ is class containing methods and objects for $AStar$ algorithm.
It contains a queue for open and closed list.We use C++ $dequeue$ data structure
as it provides dynamic allocation.
\\\\
One of routines required is to check if node is present in the closed list
\begin{minted}{cpp}
    bool AStart::isClosed(GNode c)
    {
      //iterate over elements in the closed list
        std::deque<GNode>::iterator it=closed.begin();
        for(it=closed.begin();it!=closed.end();it++)
        {
            GNode ix=*it;
            //if node is found return status
            if(ix.position==c.position)
            {
                return true;
            }
        }
        return false;
    } 
\end{minted}
Another method required is to add elements to open list
\\\\
Instead of set we can also use a priority queue data structure for implementation.
\\\\
The queue is sorted according to the cost associated with the node.
Higher to cost lower is priority ,lower the cost higher the priority.
\\\\
The higest priority node is placed at top of queue while lower once
are placed at the bottom.
\\\\
Thus when adding a new element to the queue,it must be added at proper location
\\\\
Also if a element is present in the open list,we replace it only if cost is lower
than element being inserted.
\\\\
We insert an element in priority queue only if node being inserted has higher priority.
\\\\
To insure we do operation in a single pass,we insert the node irrespective of whether it is
present in queue or not at suitable position.And set a flag called insert\_flag to indicate that.
\\\\
If the same node is encountered after insert flag is set to true that means node is of lower
priority and we erase the node encountered as higher priority node has already been inserted in the queue.
\\\\
If we encounter the node in the open list and its priority is higher,then we do not insert the
node.
\\\\
\begin{minted}{cpp}
 bool addOpen(GNode &node)
    {

        std::deque<GNode>::iterator it=open.begin();
        std::deque<GNode>::iterator it1=open.end();
        
        bool flag=false;	//return status
        bool insert_flag=false;//insert flag
        //compute the cost of node being inserted
        
        float val2=node.getCost(goal,maxc);
        for(it=open.begin();it!=open.end();it++)
        {
	    //compute cost of current node in queue
            float val1=(*it).getCost(goal,maxc);
            if(((*it).position==node.position))
            {
                if(insert_flag==true)
                {
                //reopening node
                    it=open.erase(it);rccopen++;                                        
                }
                insert_flag=true;
                break;
            }
            if(val2<val1 &&insert_flag==false)
            {                
                it=open.insert(it,node);                                
                insert_flag=true;
            }

        }

        if(insert_flag==false)
        {            
            open.push_back(node);
            flag=true;
        }        
        return flag;
    }
 
\end{minted}
We also need to determine the node is accessible or not.A dense grid is precomputed
which tell us if current position lies inside obstacle or not.
the variable $\texttt{obstacle\_map}$ contains this map.
\\\\
Thus we are given the current node and successor.
\\\\
We compute the unit vector along the direction of movement and take small steps
along this direction every time checking if point lies in the obstacle or not.
\\\\
This approach will give is node is accessible or not even in case of large grid sizes,
where nodes may be on opposite side of obstacle.
\begin{minted}{cpp}
 bool isAccessible(GNode &n,GNode &n1,int mode)
    {

        float dx=n.position.x-n1.position.x;
        float dy=n.position.y-n1.position.y;
        float mag=sqrt(dx*dx+dy*dy);
        dx=dx/mag;
        dy=dy/mag;

        Point2f p=n1.position;
        p.x=n1.position.x;
        p.y=n1.position.y;
        while(1)
        {
            if(p.x==n.position.x && p.y==n.position.y)
            {
                break;
            }

            //current position and initial position
            float dx2=p.x-n1.position.x;
            float dy2=p.y-n1.position.y;
            float mag1=sqrt(dx2*dx2+dy2*dy2);

            //current position and goal position
            float dx1=p.x-n.position.x;
            float dy1=p.y-n.position.y;
            float dd=sqrt((dx1*dx1)+(dy1*dy1));
            //goal position lies withing minimum grid resolution
            if(dd<=minr && mode==1)
            {
                return true;
            }
	    //no obstacle found
	    if(mag1>=mag)
            {
                return true;
            }

            
        prev=p;
        Point2f ff=Point2f(p.x,-p.y);

        if(ff.y >=obstacle_map.rows || ff.x>=obstacle_map.cols || ff.x<0 ||ff.y<0)
        {
            n1.open=false;
            return false;
        }
        int val=(int)obstacle_map.ptr<uchar>(((int)ff.y))[((int)ff.x)];
        if(val>0)
        {

            n.open=false;
            return false;
        }
        //take small increment
        p.x=p.x+(1)*dx;
        p.y=p.y+(1)*dy;
            
            
        }
        return true;
     }
\end{minted}
\section{Simulation}
Simulation outputs can be found at
\url{https://github.com/pi19404/m19404/tree/master/robot/navigation/AStar/}
\section{Code}
The files AStar.hpp,AStar.cpp define the AStart Algorithm.The files gsim.hpp,gsim.cpp
defines the simulation environment.
The code can be found at \url{https://github.com/pi19404/m19404/tree/master/robot/navigation/AStar}
\\\\
Images for test simulation and output simulation videos can also be found in the repository
\\\\
Run the code as follows \\\\
AStar obstales1.png 10  \\\\
where 10 is distance between nodes
\\\\
%\section{PDF}
%The PDF version of the document can be found at 
%\addcontentsline{toc}{section}
%\printbibliography 
%\nocite{*}
\end{document}

% @misc{a et~al(2007)a,
%       title = "Dynamic Time Warping",
%        note = {at \url{http://web.science.mq.edu.au/~cassidy/comp449/html/ch11s02.html}},
%        year = {2007},
% }
% @INPROCEEDINGS{b et~al(2007)b,
%     author = {Ricardo, Gutierrez-Osuna},
%     title = {Introduction to Speech Processing},
%     booktitle = {CSE@TAMU},    
%      year = {2007},
% }